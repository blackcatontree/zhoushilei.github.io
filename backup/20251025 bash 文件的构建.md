## 基础操作
```shell
# 强制清除文件
rm -f name.txt # 强制清除文件
# 文本检索
ligand_charge=$(grep $pdbid /home/zsl/ligand.txt | awk "{print $2}") #|前检索出的行，|后输出第二列
# 批处理操作
cat batch.txt | parallel --env _ --joblog 02.log --retries 3 --jobs 16 process_pdbid {} #批处理操作（base txt 文档）
find "/home/tmp/zsl/data" -maxdepth 1 -type d -name "GID*" | sort | while read dir; do
   pdbid=$(basename"$dir")
   echo "$pdbid"
done | parallel --joblog 02.log --retries 3 --jobs 16 01_ligand_process{} # 批处理操作（base find文件夹名称检索）

# 调用bash文件
cd /home/test
chmod +x 02_protein_process.sh #增加权限
./02_protein_process.sh #直接运行
```
## IF语句
``` shell
if [[ $? -eq 0]]; then
    gmx editconf -f ${pdbid}_protein.gro -o ${pdbid}_protein_H.pdb -nobackup > /dev/null 2>&1 #gro 转化为pdb文件，现在已经去掉了H
    python $base_directory/02_protein_process/0202_addchain.py\
        --pdbfile ${pdbid}_protein_H.pdb \
        --pdbid $pdbid\
        --outdir $outdir #结束不需要反斜杠
else
    echo "${pdbid} pdb2gmx failed. Check pdb2gmx.out for details."
    echo ${pdbid} >> $base_directory/02_protein_process/nonstandard_residue.txt
fi   
``` 
## function defination
```shell
02_protein_process() {
    # defination
    base_directory=$(pwd)#当前文件夹
    local pdbfile="${base_directory}/data/$pdbid/protein/${pdbid}_protein_0_fixed.pdb"
    
    # action
    mkdir -p $outdir
    cd $outdir
    
    # python
    python $base_directory/0201_dump_protein.py\
        --pdbfile $pdbfile\
        --ligandfile $ligandfile\
        --pdbid $pdbid\
        --outdir $outdir
}
# function 调用
export -f 02_protein_process #将函数导入到shell环境中
```
