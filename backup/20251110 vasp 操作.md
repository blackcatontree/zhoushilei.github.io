## vaspkit的编译
1. 教程：[vaspkit编译](https://zhuanlan.zhihu.com/p/680752546)
2. 添加到bashrc
```shell
# 添加到 ~/.bashrc
echo 'export PATH=$PATH:/home/dataset-assist-0/tmp/zsl/DFT/vaspkit.1.5.1/bin' >> ~/.bashrc
source ~/.bashrc
```
3. 保存镜像

4. 验证

```shell
which vaspkit
vaspkit --version
```
## vaspkit 固定原子（按照高度固定）
1. 教程：https://zhuanlan.zhihu.com/p/687033002

## 结构优化文件设置
1. KPOINTS

```shell
KPOINTS
KPOINTS
0
Gamma
3 3 1
0 0 0
```
2. POSTAR
```shell
SYSTEM = CoSe2 slab relax
# —— 精度 ——
ENCUT  = 520
PREC   = Normal
EDIFF  = 1E-5
# 可考虑稍严格的力收敛（对表面研究）
EDIFFG = -0.01  # 从-0.02提高到-0.01 eV/Å

# —— 金属性/展宽 ——
ISMEAR = 0
SIGMA  = 0.05

# —— 自旋（CoSe2 表面建议开自旋） ——
ISPIN  = 2
MAGMOM = 72*2.5 144*0.1    # 72 个 Co 给 2.0 μB 初始，Se 给 0

# 如果文献表明CoSe₂需要+U，建议现在就加上：
LDAU = .TRUE.
LDAUTYPE = 2
LDAUL = 2 -1     # Co-d, Se-p
LDAUU = 4.0 0.0  # U值需根据文献调整
LDAUJ = 0.0 0.0

# —— 几何优化与算法 ——
IBRION = 2
NSW    = 150
ISIF   = 2
ALGO   = Normal
LASPH  = .TRUE. # 精度项
LREAL  = .TRUE.
ISYM   = 0

# —— 色散 & 偶极修正 ——
IVDW   = 12
LDIPOL = .TRUE.
IDIPOL = 3
LASPH  = .TRUE. 
KPAR   = 1           # = 你用的 GPU 张数（两张就写 2）
NBANDS = 1000 分配容易显存爆炸
NELM = 120 # 电子步上限，稳一下
```
3. 赝势文件potcar形成
（1）下载赝势文件   https://www.bilibili.com/opus/792602409042968599
（2）制作POTCAR：POTCAR 文件时把各个元素的势文件按照POSCAR 的元素顺序拼接起来
```shell
# 假设你的库根在 $VASP_PP_PATH，优先用 Co_pv，其次 Co；Se 用 Se
[ -f "$VASP_PP_PATH/Co_pv/POTCAR" ] && CO_DIR="$VASP_PP_PATH/Co_pv" || CO_DIR="$VASP_PP_PATH/Co"
SE_DIR="$VASP_PP_PATH/Se"

cat "$CO_DIR/POTCAR" > POTCAR
cat "$SE_DIR/POTCAR" >> POTCAR

# 快速核对
grep TITEL POTCAR        # 应显示先 Co... 再 Se...

```
```shell
cd /home/dataset-assist-0/tmp/zsl/DFT/cry_surface/c4_100
export VASP_PP_PATH="/home/dataset-assist-0/tmp/zsl/DFT/PAW_PBE"

[ -f "$VASP_PP_PATH/Co_pv/POTCAR" ] && CO_DIR="$VASP_PP_PATH/Co_pv" || CO_DIR="$VASP_PP_PATH/Co"
SE_DIR="$VASP_PP_PATH/Se"

cat "$CO_DIR/POTCAR" > POTCAR
cat "$SE_DIR/POTCAR" >> POTCAR

grep TITEL POTCAR

```
## 运行计算
### 没有显卡的方式
1. 查看显卡是否在使用：
```shell
nvidia-smi
nvidia-smi --query-compute-apps=pid,process_name,used_memory --format=csv,noheader,nounits
```
2. 查看有没有cpu在使用
```shell
# 查看VASP进程
ps aux | grep vasp
top -u $USER
```
3. 实际的计算过程
```shell
# 设置环境
ulimit -s unlimited
export OMP_NUM_THREADS=1

# 方式1：前台运行，实时看到输出
mpirun -np 16 vasp_std |& tee -a relax.out

# 方式2：后台运行，输出到文件
nohup mpirun -np 16 vasp_std >> relax.out 2>&1 &
```
4. 多节点的CPU运行
```shell
# 使用作业调度系统（SLURM）
sbatch job_script.slurm

# job_script.slurm 内容示例：
#!/bin/bash
#SBATCH -N 2           # 2个节点
#SBATCH --ntasks-per-node=16  # 每个节点16进程
#SBATCH -p compute     # 计算队列

mpirun vasp_std
```

### 有显卡的方式
1. 查看显卡是否在使用
2. 判断使用几个卡：
**(1)一个机器一个卡**：`mpirun -np 1 -mca coll ^hcoll vasp_std |& tee -a relax.out` ；表示进程数量为1，兼容性进行GPU计算，采用vasp_std 进行计算，最后进行错误和输出的重定型和打印。该命令适合
`export CUDA_VISIBLE_DEVICES=0 # GPU计算环境`
`mpirun -np 1 vasp_std |& tee -a test.out #小体系调试`
**（2） 多进程的CPU版本：**
`mpirun -np 16 vasp_std |& tee -a relax.out #16进程的CPU计算`
**（3）多进程的GPU版本：**
`export CUDA_VISIBLE_DEVICES=0,1 # 2个GPU，每GPU1个进程`
`mpirun -np 2 -mca coll ^hcoll vasp_std |& tee -a relax.out`
**(4) 后台运行版本：**
`nohup mpirun -np 1 -mca coll ^hcoll vasp_std >> relax.out 2>&1 & # 后台运行，输出到文件`
另外：
`tail -f relax.out` 实时监控输出
`tail -f OSZICAR` 实时查看计算进度
4. 运行(1)  终端显示迭代（能量、力）：`mpirun -np 16 vasp_std |& tee -a relax.out`(2)  后台跑，输出重定向到文件:

### 混合计算
```shell
# 使用部分CPU核心辅助GPU
export CUDA_VISIBLE_DEVICES=0
export OMP_NUM_THREADS=4
mpirun -np 1 -mca coll ^hcoll vasp_std |& tee -a relax.out

```

### 显卡的修改
1. 使用0显卡进行：
```shell
# 当前任务已经在GPU 0上运行
export CUDA_VISIBLE_DEVICES=0
mpirun -np 1 -mca coll ^hcoll vasp_std |& tee -a relax.out

```
2. 使用1显卡运行
```shell
# 在新终端中，进入另一个计算目录
cd /path/to/your/second/calculation

# 设置使用GPU 1
export CUDA_VISIBLE_DEVICES=1
export OMP_NUM_THREADS=1
ulimit -s unlimited

# 启动第二个计算
mpirun -np 1 -mca coll ^hcoll vasp_std |& tee -a relax.out
```


